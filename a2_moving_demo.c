#pragma config(Sensor, S4,     Colour,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S1,     Colour2,         sensorEV3_Color, modeEV3Color_Color)
#pragma config(Motor,  motorD,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorA,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
#pragma DebuggerWindows("debugStream")

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int myArray[4] = { 5, 8, 10, 12};
int myTime[4] = { 10, 20, 30, 40};

int dir = 0;
int counter = 0;
int left = 50;
int right = 50;
int latency = 20;


//for color
short rightcurrentColour;
short leftcurrentColour;

bool leftBlack;
bool rightBlack;

task main()
{
	while (true)
	{

		rightcurrentColour = SensorValue[Colour];
		leftcurrentColour = SensorValue[Colour2];

		switch(rightcurrentColour)
		{
			case 0:  displayCenteredBigTextLine(4, "none");
								rightBlack = true;
								break;
			case 1:  displayCenteredBigTextLine(4, "black");
								rightBlack = true;
								break;
			case 2:	 displayCenteredBigTextLine(4, "blue");
				rightBlack = false;
				break;
			case 3:	 displayCenteredBigTextLine(4, "green");
				rightBlack = false;
				break;
			case 4:	 displayCenteredBigTextLine(4, "yellow");
			rightBlack = false;
			break;
			case 5:	 displayCenteredBigTextLine(4, "red");
			rightBlack = false;
			break;
			case 6:	 displayCenteredBigTextLine(4, "white");
								rightBlack = false;
								break;
			case 7:	 displayCenteredBigTextLine(4, "brown");
			rightBlack = false;
			break;
			default:
			rightBlack = false;
			displayCenteredBigTextLine(4, "unknown");


		}
		switch(leftcurrentColour)
		{
			case 0:  displayCenteredBigTextLine(7, "none");
			leftBlack = true;
			break;
			case 1:  displayCenteredBigTextLine(7, "black");
								leftBlack = true;
								break;
			case 2:	 displayCenteredBigTextLine(7, "blue");
			leftBlack = false;
			break;
			case 3:	 displayCenteredBigTextLine(7, "green");
			leftBlack = false;
			break;
			case 4:	 displayCenteredBigTextLine(7, "yellow");
			rightBlack = false;
			break;
			case 5:	 displayCenteredBigTextLine(7, "red");
			rightBlack = false;
			break;
			case 6:	 displayCenteredBigTextLine(7, "white");
								leftBlack = false;
								break;
			case 7:	 displayCenteredBigTextLine(7, "brown");
			rightBlack = false;
			break;
			default:
			rightBlack = false;
			displayCenteredBigTextLine(7, "unknown");
		}

		//int randomNumber = random(1);
		//int randomSpeed = 40 + random(40);
		if((leftBlack == rightBlack) && (leftBlack == true)){
			counter++;
			//writeDebugStreamLine("The random value at %d ", counter);
			if(counter > latency){
				if(dir == 1 ){
					//left = randomSpeed;
					right = 50;
					left += myArray[random(3)];
					writeDebugStreamLine("Right  %d",myArray[random(3)] );
					dir = 0;
					} else {
						left = 50;
						//right = randomSpeed;
			  		right += myArray[random(3)];
						writeDebugStreamLine("Left	%d",myArray[random(3)]);
						dir = 1;
					}
					counter =0;
					latency = myTime[random(3)];
	  		}
				writeDebugStreamLine("The left speed is %d and the right is %d ", left, right);
				setMotorSpeed(motorLeft, left);
				setMotorSpeed(motorRight, right);

			}else{
				setMotorSpeed(motorLeft, 0);
				setMotorSpeed(motorRight, 0);
		// wandering code ends



		//Loop to monitor value in Sensor debugger window
		//sleep(50);
		}
	}
}
