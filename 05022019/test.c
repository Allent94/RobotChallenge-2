#pragma config(Sensor, S1,     Colour,         sensorEV3_Color, modeEV3Color_Reflected)
#pragma config(Sensor, S4,     Colour2,         sensorEV3_Color, modeEV3Color_Reflected)
#pragma config(Motor,  motorD,          motorLeft,     tmotorEV3_Large, PIDControl, encoder)
#pragma config(Motor,  motorA,          motorRight,    tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*
Colour sensor modes
0 - modeEV3Color_Reflected
1 - modeEV3Color_Ambient
2 - modeEV3Color_Color
3 - modeEV3Color_Reflected_Raw
4 - modeEV3Color_RGB_Raw
5 - modeEV3Color_Calibration - Not utilized
*/
int left = 10;
int right = 10;
int max = 10;
task main()
{

	while (true)
	{

		// Write the amount of reflected light to the screen
		// This is a value between 0 and 100, where 0 means no reflected
		// light and 100 means all light is being reflected
		displayBigTextLine(6, "L: %d R: %d", SensorValue[Colour], SensorValue[Colour2]);

		if((SensorValue[Colour] < 20) || ( SensorValue[Colour2] < 20)){
			displayBigTextLine(9 ,"inside statement");
			//playTone(100, true);
			if(SensorValue[Colour] < SensorValue[Colour2]) {
				int difference = (SensorValue[Colour2] - SensorValue[Colour]);
				if(difference > max) {
					difference = max - 3;
				}
				setMotorSpeed(motorLeft, left);
				setMotorSpeed(motorRight, right-difference);
				// displayBigTextLine(
				} else {
				int difference = (SensorValue[Colour] - SensorValue[Colour2]);
				if(difference > max) {
					difference = max - 3;
				}
				//float speedChange = base * ((SensorValue[Colour2] + 1) / (SensorValue[Colour] + 1 + SensorValue[Colour2]));
				setMotorSpeed(motorLeft, left-difference );
				setMotorSpeed(motorRight, right);
			}

			}else{
			setMotorSpeed(motorLeft, left);
			setMotorSpeed(motorRight, right);
			displayBigTextLine(9 ,"not inside statement");
		}

		// Wait 20 ms to get 50 readings per second
		//sleep(20);
	}
}
